#include "plutocore.h"

seq_t
seqtoid
(
 char * seq,
 int   slen
)
{
   seq_t seqid = 0;
   for (int j = 0; j < slen ; j++) {
      if (seq[j] == 'C' || seq[j] == 'c') seqid += 1;
      else if (seq[j] == 'G' || seq[j] == 'g') seqid += 2;
      else if (seq[j] == 'T' || seq[j] == 't') seqid += 3;
      else return BAD_SEQ;
      seqid <<= 2;
   }

   return seqid;   
}

seq_t*
seqtoid_N
(
 char * seq,
 int  * nids,
 int    slen
 )
// SYNOPSIS:                                                              
//   Generates the ID of the sequence pointed by seq. If the sequence
//   contains up to 'MAXUNKN' unknowns ('N'), seqid generates all the
//   combinations of the sequence obtained by replacing 'N' by 'ACTG'.
//   The function returns NULL otherwise.
//                                                                        
// PARAMETERS:                                                            
//   seq: String of the sequence (null-termination is not necessary).
//                                                                        
// RETURN:                                                                
//   Pointer to an array of uints containing all the ids or
//   NULL if the number of unknowns is found to be greater than MAXUNKN.
//   *nids: number of sequence ids generated by substituting unknowns.
//                                                                        
// SIDE EFFECTS:                                                          
//   None.
//   
{
   char nunkn = 0;

   // Count number of unknowns.
   for (int j = 0; j < slen; j++)
      nunkn += (seq[j] == 'N' || seq[j] == 'n');

   // Return NULL if max amount of 'N' has been reached.
   if (nunkn > MAXUNKN) return NULL;
      
   // Initialize seq ids.
   int nseqs = 1 << (2*nunkn);
   seq_t * seqid = (seq_t *) malloc(nseqs * sizeof(seq_t));
   for (int k = 0; k < nseqs; k++) seqid[k] = 0;

   // Generate sequence ids.
   for (int j = 0, u = nseqs/4; j < slen ; j++) {
      switch(seq[j]) {
      case 'C':
         for (int k = 0; k < nseqs; k++) seqid[k] += 1;
         break;
      case 'G':
         for (int k = 0; k < nseqs; k++) seqid[k] += 2;
         break;
      case 'T':
         for (int k = 0; k < nseqs; k++) seqid[k] += 3;
         break;
      case 'N':
         for (int k = 0; k < nseqs; k++) seqid[k] += (k/u) % 4;
         u /= 4;
         break;
      }
      if (j < slen - 1)
         for (int k = 0; k < nseqs; k++) seqid[k] <<= 2;
   }

   *nids = nseqs;
   return seqid;
}

char*
idtoseq
(
 seq_t seqid,
 int  slen
)
// SYNOPSIS:                                                              
//   Reverts the sequence associated with the given ID.
//                                                                        
// PARAMETERS:                                                            
//   seqid: the sequence ID.
//                                                                        
// RETURN:                                                                
//   A string containing the sequence.
//                                                                        
// SIDE EFFECTS:                                                          
//   Allocates 15 bytes to fit the sequence that must be manually freed.
//   
{
   char bases[4] = {'A','C','G','T'};
   char * seq = malloc(slen+1);
   for (int i= 0; i<slen; i++)
      seq[slen-1-i] = bases[(seqid >> 2*i) & 3];

   return seq;
}

loc_t
getloci
(
 seq_t    seq_id,
 loc_t  * lut,
 loc_t  * index,
 loc_t ** list
)
// SYNOPSIS:                                                              
//   Given a genome LUT and its index, retrieves the address of the loci list
//   that correspond to the specified sequence id.
//                                                                        
// PARAMETERS:                                                            
//   seq_id: the node id containing the queried sequence.
//   lut:    an mmaped pointer to the genome lookup table.
//   index:  an mmaped pointer to the genome index file.
//   list:   pointer where the starting address of the list will be placed.
//                                                                        
// RETURN:                                                                
//   Returns the size of the list if any match has been found for the specified
//   sequence or 0 otherwise.
//   'list' will contain either the address of the first element in the list or 
//   NULL if the sequence does not match any existing loci.
//                                                                        
// SIDE EFFECTS:                                                          
//   None.
//   
{
   // Clear height bits, just in case.
   seq_id &= SEQMASK;

   // Get the number of loci in the genome. (Stored at index[0]).
   loc_t nloci = index[0];
   

   // Get the address offset of the 1st locus.
   loc_t start = lut[seq_id];
   if (start == 0) {
      *list = NULL;
      return 0;
   }

   // Find the next node to infer the offset.
   loc_t end = 0;
   seq_id++;
   while (seq_id < NSEQ)
      if (lut[seq_id] != 0) break;
      else seq_id++;

   if (seq_id < NSEQ) end = lut[seq_id];
   else               end = nloci;

   // Point to the beginning of the list and return the list size.
   *list = index + start;
   return end - start;
}

loc_t
addloci
(
 seq_t       seq_id,
 loc_t     * lut,
 loc_t     * index,
 lstack_t ** ustackp
)
// SYNOPSIS:                                                              
//   Same as getloci, but directly appends the content of the loci list to a
//   stack of uints, instead of returning the address of the list.
//                                                                        
// PARAMETERS:                                                            
//   seq_id: the node id containing the queried sequence.
//   lut:    an mmaped pointer to the genome lookup table.
//   index:  an mmaped pointer to the genome index file.
//   ustack: uint stack where the loci will be appended.
//                                                                        
// RETURN:                                                                
//   The number of inserted loci.
//                                                                        
// SIDE EFFECTS:                                                          
//   May realloc the stack.
//   
{
   ustack_t * ustack = *ustackp;
   // Get the loci list.
   loc_t * list;
   loc_t   nloc = getloci(seq_id, lut, index, &list);
   if (nloc == 0) return 0;

   // TODO: CHECK HERE FOR POSSIBLE HIGHLY REPEATED SEQUENCES.
   
   // Realloc the stack if needed.
   if (ustack->pos + nloc > ustack->lim) {
      loc_t newsize = ustack->pos + nloc;
      ustack_t * p = realloc(ustack, (newsize+2) * sizeof(loc_t));
      if (p == NULL) {
         fprintf(stderr, "error extending ustack (realloc): %s\n", strerror(errno));
         exit(EXIT_FAILURE);
      }
      *ustackp = ustack = p;
      ustack->lim = newsize;
   }
   
   // Copy data and update index.
   memcpy(ustack->u + ustack->pos, list, nloc*sizeof(loc_t));
   ustack->pos += nloc;

   return nloc;
}



lstack_t *
new_lstack
(
  int size
)
{
   lstack_t * ustack = malloc(2*sizeof(int) + size*sizeof(loc_t));
   if (ustack == NULL) {
      fprintf(stderr, "error allocating ustack (malloc): %s\n", strerror(errno));
      exit(EXIT_FAILURE);
   }

   ustack->pos = 0;
   ustack->lim = size;

   return ustack;
}



void
lstack_add
(
 lstack_t ** lstackp,
 loc_t       value
)

{
   lstack_t * lstack = *lstackp;
   
   // Realloc the stack if needed.
   if (lstack->pos >= lstack->lim) {
      uint newsize = 2 * lstack->lim;
      lstack_t * p = realloc(lstack, (newsize+2) * sizeof(uint));
      if (p == NULL) {
         fprintf(stderr, "error extending lstack (realloc): %s\n", strerror(errno));
         exit(EXIT_FAILURE);
      }
      *lstackp = lstack = p;
      lstack->lim = newsize;
   }
   
   // Add value.
   lstack->u[lstack->pos++] = value;
}

void
copy_lstack
(
 lstack_t ** dstp,
 lstack_t ** srcp
)
{
   lstack_t * src = *srcp;
   lstack_t * dst;
   
   size_t dstsz = src->pos*sizeof(loc_t) + 2*sizeof(int);
   dst = *dstp = realloc(*dstp, dstsz);

   memcpy(dst, src, dstsz);
   dst->lim = src->pos;
}


int
get_prefixlen
(
 seq_t seqa,
 seq_t seqb,
 int  slen
)

{
   int len = slen;
   // TODO:
   // - Seqmask depends on slen. (Maybe a macro SEQMASK(slen))
   seqa &= SEQMASK;
   seqb &= SEQMASK;
   while (((seqa >> 2*(slen - len))&3 != (seqb >> 2*(slen - len))&3) && len > 0) len--;
   
   return len;
}
