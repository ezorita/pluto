#include "plutocore.h"

uint*
seqtoid
(
 char * seq,
 int  * nids
 )
// SYNOPSIS:                                                              
//   Generates the ID of the sequence pointed by seq. If the sequence
//   contains up to 'MAXUNKN' unknowns ('N'), seqid generates all the
//   combinations of the sequence obtained by replacing 'N' by 'ACTG'.
//   The function returns NULL otherwise.
//                                                                        
// PARAMETERS:                                                            
//   seq: String of the sequence (null-termination is not necessary).
//                                                                        
// RETURN:                                                                
//   Pointer to an array of uints containing all the ids or
//   NULL if the number of unknowns is found to be greater than MAXUNKN.
//   *nids: number of sequence ids generated by substituting unknowns.
//                                                                        
// SIDE EFFECTS:                                                          
//   None.
//   
{
   char nunkn = 0;

   // Count number of unknowns.
   for (int j = 0; j < SEQLEN; j++)
      nunkn += (seq[j] == 'N' || seq[j] == 'n');

   // Return NULL if max amount of 'N' has been reached.
   if (nunkn > MAXUNKN) return NULL;
      
   // Initialize seq ids.
   int nseqs = 1 << (2*nunkn);
   uint * seqid = (uint *) malloc(nseqs * sizeof(uint));
   for (int k = 0; k < nseqs; k++) seqid[k] = 0;

   // Generate sequence ids.
   for (int j = 0, u = nseqs/4; j < SEQLEN ; j++) {
      switch(seq[j]) {
      case 'C':
         for (int k = 0; k < nseqs; k++) seqid[k] += 1;
         break;
      case 'G':
         for (int k = 0; k < nseqs; k++) seqid[k] += 2;
         break;
      case 'T':
         for (int k = 0; k < nseqs; k++) seqid[k] += 3;
         break;
      case 'N':
         for (int k = 0; k < nseqs; k++) seqid[k] += (k/u) % 4;
         u /= 4;
         break;
      }
      if (j < SEQLEN - 1)
         for (int k = 0; k < nseqs; k++) seqid[k] <<= 2;
   }

   *nids = nseqs;
   return seqid;
}

char*
idtoseq
(
  uint seqid
)
// SYNOPSIS:                                                              
//   Reverts the sequence associated with the given ID.
//                                                                        
// PARAMETERS:                                                            
//   seqid: the sequence ID.
//                                                                        
// RETURN:                                                                
//   A string containing the sequence.
//                                                                        
// SIDE EFFECTS:                                                          
//   Allocates 15 bytes to fit the sequence that must be manually freed.
//   
{
   char bases[4] = {'A','C','G','T'};
   char * seq = malloc(SEQLEN+1);
   for (int i= 0; i<SEQLEN; i++)
      seq[SEQLEN-1-i] = bases[(seqid >> 2*i) & 3];

   return seq;
}


uint
getloci
(
 uint seq_id,
 uint * index,
 uint * genome_loci,
 uint ** list
)
// SYNOPSIS:                                                              
//   Given a genome index and its loci list, generates the list of loci
//   that correspond to the specified sequence id.
//                                                                        
// PARAMETERS:                                                            
//   seq_id:      the node id containing the queried sequence.
//   index:       an mmap pointer to an index file. (.pif)
//   genome_loci: an mmap pointer to the genome loci file. (.plf)
//   list:        pointer where the starting address of the list will be placed.
//                                                                        
// RETURN:                                                                
//   Returns the size of the list if any match has been found for the specified
//   sequence and 0 otherwise.
//   'list' will contain either the address of the first element in the list or 
//   NULL if the sequence does not match any existing loci.
//                                                                        
// SIDE EFFECTS:                                                          
//   None.
//   
{
   // Clear height bits, just in case.
   seq_id &= SEQMASK;

   // Get the number of loci in the genome. (Stored at genome_loci[0]).
   uint nloci = genome_loci[0];
   

   // Get the address offset of the 1st locus.
   uint start = index[seq_id];
   if (start == 0) {
      *list = NULL;
      return 0;
   }

   // Find the next node to infer the offset.
   uint end = 0;
   seq_id++;
   while (seq_id < NSEQ)
      if (index[seq_id] != 0) break;
      else seq_id++;

   if (seq_id < NSEQ) end = index[seq_id];
   else               end = nloci;

   // Point to the beginning of the list and return the list size.
   *list = genome_loci + start;
   return end - start;
}


uint
nodeaddr
(
  uint nodeid
)
// SYNOPSIS:                                                              
//   Computes the address offset in the tree of the sequence for a given node id.
//                                                                        
// PARAMETERS:                                                            
//   nodeid: the node id.
//                                                                        
// RETURN:                                                                
//   Address offset of the given node in the tree.
//                                                                        
// SIDE EFFECTS:                                                          
//   None.
//   
{
   return (HOFFSET & (SEQMASK >> (2*(SEQLEN-((nodeid>>28) & 0x0000000F))))) + ((nodeid & SEQMASK) >> (2*(SEQLEN-((nodeid>>28) & 0x0000000F))));
}
