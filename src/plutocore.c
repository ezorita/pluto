#include "plutocore.h"

uint*
seqtoid
(
 char * seq,
 uint * nids
 )
// SYNOPSIS:                                                              
//   Generates the ID of the sequence pointed by seq. If the sequence
//   contains up to 'MAXUNKN' unknowns ('N'), seqid generates all the
//   combinations of the sequence obtained by replacing 'N' by 'ACTG'.
//   The function returns NULL otherwise.
//                                                                        
// PARAMETERS:                                                            
//   seq: String of the sequence (null-termination is not necessary).
//                                                                        
// RETURN:                                                                
//   Pointer to an array of uints containing all the ids or
//   NULL if the number of unknowns is found to be greater than MAXUNKN.
//   *nids: number of sequence ids generated by substituting unknowns.
//                                                                        
// SIDE EFFECTS:                                                          
//   None.
//   
{
   char nunkn = 0;

   // Count number of unknowns.
   for (int j = 0; j < SEQLEN; j++)
      nunkn += (seq[j] == 'N' || seq[j] == 'n');

   // Return NULL if max amount of 'N' has been reached.
   if (nunkn > MAXUNKN) return NULL;
      
   // Initialize seq ids.
   int nseqs = 1 << (2*nunkn);
   uint * seqid = (uint *) malloc(nseqs * sizeof(uint));
   for (int k = 0; k < nseqs; k++) seqid[k] = 0;

   // Generate sequence ids.
   for (int j = 0, u = nseqs/4; j < SEQLEN ; j++) {
      switch(seq[j]) {
      case 'C':
         for (int k = 0; k < nseqs; k++) seqid[k] += 1;
         break;
      case 'G':
         for (int k = 0; k < nseqs; k++) seqid[k] += 2;
         break;
      case 'T':
         for (int k = 0; k < nseqs; k++) seqid[k] += 3;
         break;
      case 'N':
         for (int k = 0; k < nseqs; k++) seqid[k] += (k/u) % 4;
         u /= 4;
         break;
      }
      if (j < SEQLEN - 1)
         for (int k = 0; k < nseqs; k++) seqid[k] <<= 2;
   }

   *nids = nseqs;
   return seqid;
}

char*
idtoseq
(
  uint seqid
)
// SYNOPSIS:                                                              
//   Reverts the sequence associated with the given ID.
//                                                                        
// PARAMETERS:                                                            
//   seqid: the sequence ID.
//                                                                        
// RETURN:                                                                
//   A string containing the sequence.
//                                                                        
// SIDE EFFECTS:                                                          
//   Allocates 15 bytes to fit the sequence that must be manually freed.
//   
{
   char bases[4] = {'A','C','G','T'};
   char * seq = malloc(SEQLEN+1);
   for (int i= 0; i<SEQLEN; i++)
      seq[SEQLEN-1-i] = bases[(seqid >> 2*i) & 3];

   return seq;
}

uint
getloci
(
 uint    seq_id,
 uint  * lut,
 uint  * index,
 uint ** list
)
// SYNOPSIS:                                                              
//   Given a genome LUT and its index, retrieves the address of the loci list
//   that correspond to the specified sequence id.
//                                                                        
// PARAMETERS:                                                            
//   seq_id: the node id containing the queried sequence.
//   lut:    an mmaped pointer to the genome lookup table.
//   index:  an mmaped pointer to the genome index file.
//   list:   pointer where the starting address of the list will be placed.
//                                                                        
// RETURN:                                                                
//   Returns the size of the list if any match has been found for the specified
//   sequence or 0 otherwise.
//   'list' will contain either the address of the first element in the list or 
//   NULL if the sequence does not match any existing loci.
//                                                                        
// SIDE EFFECTS:                                                          
//   None.
//   
{
   // Clear height bits, just in case.
   seq_id &= SEQMASK;

   // Get the number of loci in the genome. (Stored at index[0]).
   uint nloci = index[0];
   

   // Get the address offset of the 1st locus.
   uint start = lut[seq_id];
   if (start == 0) {
      *list = NULL;
      return 0;
   }

   // Find the next node to infer the offset.
   uint end = 0;
   seq_id++;
   while (seq_id < NSEQ)
      if (lut[seq_id] != 0) break;
      else seq_id++;

   if (seq_id < NSEQ) end = lut[seq_id];
   else               end = nloci;

   // Point to the beginning of the list and return the list size.
   *list = index + start;
   return end - start;
}

uint
addloci
(
 uint        seq_id,
 uint      * lut,
 uint      * index,
 ustack_t ** ustackp
)
// SYNOPSIS:                                                              
//   Same as getloci, but directly appends the content of the loci list to a
//   stack of uints, instead of returning the address of the list.
//                                                                        
// PARAMETERS:                                                            
//   seq_id: the node id containing the queried sequence.
//   lut:    an mmaped pointer to the genome lookup table.
//   index:  an mmaped pointer to the genome index file.
//   ustack: uint stack where the loci will be appended.
//                                                                        
// RETURN:                                                                
//   The number of inserted loci.
//                                                                        
// SIDE EFFECTS:                                                          
//   May realloc the stack.
//   
{
   ustack_t * ustack = *ustackp;
   // Get the loci list.
   uint * list;
   uint   nloc = getloci(seq_id, lut, index, &list);
   if (nloc == 0) return 0;

   // TODO: CHECK HERE FOR POSSIBLE HIGHLY REPEATED SEQUENCES.
   
   // Realloc the stack if needed.
   if (ustack->pos + nloc > ustack->lim) {
      uint newsize = ustack->pos + nloc;
      ustack_t * p = realloc(ustack, (newsize+2) * sizeof(uint));
      if (p == NULL) {
         fprintf(stderr, "error extending ustack (realloc): %s\n", strerror(errno));
         exit(EXIT_FAILURE);
      }
      *ustackp = ustack = p;
      ustack->lim = newsize;
   }
   
   // Copy data and update index.
   memcpy(ustack->u + ustack->pos, list, nloc*sizeof(uint));
   ustack->pos += nloc;

   return nloc;
}

uint
nodeaddr
(
  uint nodeid
)
// SYNOPSIS:                                                              
//   Computes the address offset in the tree of the sequence for a given node id.
//                                                                        
// PARAMETERS:                                                            
//   nodeid: the node id.
//                                                                        
// RETURN:                                                                
//   Address offset of the given node in the tree.
//                                                                        
// SIDE EFFECTS:                                                          
//   None.
//   
{
   return (HOFFSET & (SEQMASK >> (2*(SEQLEN-((nodeid>>28) & 0x0000000F))))) + ((nodeid & SEQMASK) >> (2*(SEQLEN-((nodeid>>28) & 0x0000000F))));
}


ustack_t *
new_ustack
(
  uint size
)
{
   ustack_t * ustack = malloc((2 + size) * sizeof(uint));
   if (ustack == NULL) {
      fprintf(stderr, "error allocating ustack (malloc): %s\n", strerror(errno));
      exit(EXIT_FAILURE);
   }

   ustack->pos = 0;
   ustack->lim = size;

   return ustack;
}


cstack_t *
new_cstack
(
 uint size
)
{
   cstack_t * cstack = malloc(2*sizeof(uint) + size*sizeof(uchar));
   if (cstack == NULL) {
      fprintf(stderr, "error allocating cstack (malloc): %s\n", strerror(errno));
      exit(EXIT_FAILURE);
   }

   cstack->pos = 0;
   cstack->lim = size;

   return cstack;
}


cstack_t **
new_carray
(
 uint arraysize,
 uint stacksize
 )
{
   cstack_t ** carray = malloc(arraysize*sizeof(cstack_t *));
   if (carray == NULL) {
      fprintf(stderr, "error allocating carray (malloc): %s\n", strerror(errno));
      exit(EXIT_FAILURE);
   }

   for (int i = 0; i < arraysize; i++)
      carray[i] = new_cstack(stacksize);

   return carray;
}


ustack_t **
new_uarray
(
 uint arraysize,
 uint stacksize
 )
{
   ustack_t ** uarray = malloc(arraysize*sizeof(ustack_t *));
   if (uarray == NULL) {
      fprintf(stderr, "error allocating carray (malloc): %s\n", strerror(errno));
      exit(EXIT_FAILURE);
   }

   for (int i = 0; i < arraysize; i++)
      uarray[i] = new_ustack(stacksize);

   return uarray;
}


void
ustack_add
(
 ustack_t ** ustackp,
 uint        value
)

{
   ustack_t * ustack = *ustackp;
   
   // Realloc the stack if needed.
   if (ustack->pos >= ustack->lim) {
      uint newsize = 2 * ustack->lim;
      ustack_t * p = realloc(ustack, (newsize+2) * sizeof(uint));
      if (p == NULL) {
         fprintf(stderr, "error extending ustack (realloc): %s\n", strerror(errno));
         exit(EXIT_FAILURE);
      }
      *ustackp = ustack = p;
      ustack->lim = newsize;
   }
   
   // Add value.
   ustack->u[ustack->pos++] = value;
}

void
cstack_add
(
 cstack_t ** cstackp,
 uchar     * cache,
 uint        tau
)

{
   cstack_t * cstack = *cstackp;
   
   // Realloc the stack if needed.
   if (cstack->pos + 2*tau + 1 > cstack->lim) {
      uint newsize = 2 * cstack->lim;
      while (newsize < cstack->pos + 2*tau + 1)
         newsize *= 2;

      cstack_t * p = realloc(cstack, 2*sizeof(uint) + newsize*sizeof(uchar));
      if (p == NULL) {
         fprintf(stderr, "error extending cstack (realloc): %s\n", strerror(errno));
         exit(EXIT_FAILURE);
      }
      *cstackp = cstack = p;
      cstack->lim = newsize;
   }
   
   // Add cache.
   memcpy(cstack->c + cstack->pos, cache, 2*tau + 1);
   cstack->pos += 2*tau + 1;
}

void
copy_ustack
(
 ustack_t ** dstp,
 ustack_t ** srcp
)
{
   ustack_t * src = *srcp;
   ustack_t * dst;
   
   int dstsz = srcp->pos;
   dst = *dstp = realloc(*dstp, (dstsz + 2) * sizeof(uint));

   memcpy(dst->u, src->u, dstsz*sizeof(uint));
   dst->lim = dst->pos = dstsz;
}


uint
get_prefixlen
(
 uint seqa,
 uint seqb
)

{
   uint len = SEQLEN;
   seqa &= SEQMASK;
   seqb &= SEQMASK;
   while (((seqa >> 2*(SEQLEN - len))&3 != (seqb >> 2*(SEQLEN - len))&3) && len > 0) len--;
   
   return len;
}
